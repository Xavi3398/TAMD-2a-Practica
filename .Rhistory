n=dim(L)[1]
K=solve(diag(rep(1,n))+gamma*L)
return(K)
}
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Elegir els conjunts d'entrenament i test
(training.set = c(5,6,7,8,9,10))
(test.set = c(1,2,3,4))
# Emprar el model SVM
model=ksvm(K[training.set,training.set])
model
# Generate el kernel per al conjunt de test
testK <- as.kernelMatrix(K[test.set, training.set]
[,SVindex(model), drop=F])
# Predir el resultat
preds <- predict(model, testK)
preds
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Elegir els conjunts d'entrenament i test
(training.set = c(5,6,7,8,9,10))
(test.set = c(1,2,3,4))
# Emprar el model SVM
model=ksvm(K[training.set,training.set])
model
# Generate el kernel per al conjunt de test
testK <- as.kernelMatrix(K[test.set, training.set]
[,SVindex(model), drop=F])
# Predir el resultat
preds <- predict(model, testK)
preds
# Generate the kernel matrix K
kernel.vertex.classif = function(A){
B=A%*%t(A)
g2=graph_from_adjacency_matrix(B,mode="undirected")
L = as.matrix(laplacian_matrix(g2,normalized = T))
gamma = 1/max(degree(B)+1)
n=dim(L)[1]
K=solve(diag(rep(1,n))+gamma*L)
return(K)
}
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Elegir els conjunts d'entrenament i test
(training.set = c(5,6,7,8,9,10))
(test.set = c(1,2,3,4))
# Emprar el model SVM
model=ksvm(K[training.set,training.set])
model
# Generate el kernel per al conjunt de test
testK <- as.kernelMatrix(K[test.set, training.set]
[,SVindex(model), drop=F])
# Predir el resultat
preds <- predict(model, testK)
preds
# Generate the kernel matrix K
kernel.vertex.classif = function(A){
B=A%*%t(A)
g2=graph_from_adjacency_matrix(B,mode="undirected")
L = as.matrix(laplacian_matrix(g2,normalized = T))
gamma = 1/max(degree(g2)+1)
n=dim(L)[1]
K=solve(diag(rep(1,n))+gamma*L)
return(K)
}
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Generate the kernel matrix K
kernel.vertex.classif = function(A){
B=A%*%t(A)
g2=graph_from_adjacency_matrix(B,mode="undirected")
L = as.matrix(laplacian_matrix(g2,normalized = T))
gamma = 1/max(degree(B)+1)
n=dim(L)[1]
K=solve(diag(rep(1,n))+gamma*L)
return(K)
}
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Elegir els conjunts d'entrenament i test
(training.set = c(5,6,7,8,9,10))
(test.set = c(1,2,3,4))
# Emprar el model SVM
model=ksvm(K[training.set,training.set])
model
# Generate el kernel per al conjunt de test
testK <- as.kernelMatrix(K[test.set, training.set]
[,SVindex(model), drop=F])
# Predir el resultat
preds <- predict(model, testK)
preds
# Generate the kernel matrix K
kernel.vertex.classif = function(A){
B=A%*%t(A)
g2=graph_from_adjacency_matrix(B,mode="undirected")
L = as.matrix(laplacian_matrix(g2,normalized = T))
gamma = 1/max(degree(B)+1)
n=dim(L)[1]
K=solve(diag(rep(1,n))+gamma*L)
return(K)
}
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Elegir els conjunts d'entrenament i test
(training.set = c(5,6,7,8,9,10))
(test.set = c(1,2,3,4))
# Emprar el model SVM
model=ksvm(K[training.set,training.set])
model
# Generate el kernel per al conjunt de test
testK <- as.kernelMatrix(K[test.set, training.set]
[,SVindex(model), drop=F])
# Predir el resultat
preds <- predict(model, testK)
preds
# Generate the kernel matrix K
kernel.vertex.classif = function(A){
B=A%*%t(A)
g2=graph_from_adjacency_matrix(B,mode="undirected")
L = as.matrix(laplacian_matrix(g2,normalized = T))
gamma = 1/max(degree(g2)+1)
n=dim(L)[1]
K=solve(diag(rep(1,n))+gamma*L)
return(K)
}
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Generate the kernel matrix K
kernel.vertex.classif = function(A){
B=A%*%t(A)
g2=graph_from_adjacency_matrix(B,mode="undirected")
L = as.matrix(laplacian_matrix(g2,normalized = T))
gamma = 1/max(degree(B)+1)
n=dim(L)[1]
K=solve(diag(rep(1,n))+gamma*L)
return(K)
}
# Primer, calcular la matriu laplaciana normalitzada
A.h = as.array(as_adjacency_matrix(g))
K=kernel.vertex.classif(A.h)
# Elegir els conjunts d'entrenament i test
(training.set = c(5,6,7,8,9,10))
(test.set = c(1,2,3,4))
# Emprar el model SVM
model=ksvm(K[training.set,training.set])
model
# Generate el kernel per al conjunt de test
testK <- as.kernelMatrix(K[test.set, training.set]
[,SVindex(model), drop=F])
# Predir el resultat
preds <- predict(model, testK)
preds
hist(credit.card$V9, breaks = 100)
orandom = ubOver(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, k = 100)
library(unbalanced)
orandom = ubOver(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, k = 100)
table(orandom$Y)
orandom = ubOver(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, k = 500)
table(orandom$Y)
orandom = ubOver(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, k = 400)
table(orandom$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 2000)
table(osmote$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 2000, perc.under = 0)
table(osmote$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
table(osmote$Y)
# Emprar k=0 per deixar amb els mateixos exemples que classe majoritÃ ria
orandom = ubOver(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, k = 300)
table(orandom$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 2000, perc.under = 2000)
table(osmote$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 2000, perc.under = 200)
table(osmote$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 4000, perc.under = 200)
table(osmote$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 4000, perc.under = 100)
table(osmote$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 4000, perc.under = 200)
table(osmote$Y)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 40000, perc.under = 200)
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 200)
table(osmote$Y)
# Faltaria afegir a dataset original
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 200000)
# Faltaria afegir a dataset original
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 2000)
table(osmote$Y)
# Faltaria afegir a dataset original
osmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
table(osmote$Y)
hsmote = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 200)
table(hsmote$Y)
# Faltaria afegir a dataset original
osmote = credit.card
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
rbind(osmote, osmote_new)
a = rbind(osmote_new$x, osmote_new$Y)
a
a = rbind(osmote_new$X, osmote_new$Y)
a
osmote_df$Class = osmote$Y
osmote_df = osmote_new$X
osmote_df$Class = osmote$Y
osmote_df
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
osmote_df = osmote_new$X
osmote_df$Class = osmote$Y
osmote_df
osmote_df["Class"] = osmote$Y
osmote_df
osmote$Y
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
osmote$Y
osmote
# Faltaria afegir a dataset original
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
# Faltaria afegir a dataset original
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
rbind(osmote_new, credit.card)
osmote_new
osmote_new$Y
osmote_new$X
osmote_new
# Faltaria afegir a dataset original
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
# Faltaria afegir a dataset original
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
osmote_new
osmote_new
osmote_new_df = osmote_new$X
osmote_new_df$Class = osmote_new$Y
osmote_new_df
rbind(osmote_new_df, credit.card)
osmote_new_df
# Faltaria afegir a dataset original
osmote_new = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0)
osmote_new
osmote_new_df = osmote_new$X
osmote_new_df$Class = osmote_new$Y
osmote = rbind(osmote_new_df, credit.card)
table(osmote$Class)
osmote_new_df = osmote_new$X
osmote_new_df$Class = osmote_new$Y
osmote = rbind(osmote_new_df, credit.card)
table(osmote$Class)
ubsmote <- function(res_ubsmote, df){
new_df = res_ubsmote$X
new_df$Class = res_ubsmote$Y
return(rbind(new_df, df))
}
join.smote.results <- function(res_ubsmote, df){
new_df = res_ubsmote$X
new_df$Class = res_ubsmote$Y
return(rbind(new_df, df))
}
join.smote.results <- function(res_ubsmote, df){
new_df = res_ubsmote$X
new_df$Class = res_ubsmote$Y
return(rbind(new_df, df))
}
osmote = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0), credit.card)
table(osmote$Class)
h.smote.tk = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 200), credit.card)
h.smote.tk = ubTomek(X=h.smote.tk[, -ncol(credit.card)], Y=h.smote.tk$Class)
table(h.smote.tk$Class)
table(h.smote.tk$Class)
h.smote.tk = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 200), credit.card)
h.smote.tk = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 200), credit.card)
h.smote.tk
h.smote.tk = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0), credit.card)
h.smote.tk
h.smote.tk = ubTomek(X=h.smote.tk[, -ncol(credit.card)], Y=h.smote.tk$Class)
table(h.smote.tk$Class)
h.smote.tk
table(h.smote.tk$Y)
h.smote.enn = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0), credit.card)
h.smote.enn = ubENN(X=h.smote.enn[, -ncol(credit.card)], Y=h.smote.enn$Class)
table(h.smote.enn$Y)
h.smote.enn = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0), credit.card)
h.smote.enn = ubENN(X=h.smote.enn[, -ncol(credit.card)], Y=h.smote.enn$Class, k=5)
table(h.smote.enn$Y)
h.smote.enn = join.smote.results(ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 20000, perc.under = 0), credit.card)
h.smote.enn = ubENN(X=h.smote.enn[, -ncol(credit.card)], Y=h.smote.enn$Class, k=3)
table(h.smote.enn$Y)
h.urandom.smote.tk = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 2000, perc.under = 200)
h.urandom.smote.tk = ubTomek(X=h.urandom.smote.tk[, -ncol(credit.card)], Y=h.urandom.smote.tk$Class)
h.urandom.smote.tk = ubSMOTE(X=credit.card[, -ncol(credit.card)], Y=credit.card$Class, perc.over = 2000, perc.under = 200)
h.urandom.smote.tk = ubTomek(X=h.urandom.smote.tk$X, Y=h.urandom.smote.tk$Y)
table(h.urandom.smote.tk$Y)
library(unbalanced)
library(rpart)
library(rpart.plot)
library(caret)
set.seed(777)
train_ind <- sample(seq_len(nrow(credit.card)), size = floor(nrow(credit.card)*0.8), replace = FALSE)
credit.train <- credit.card[train_ind, ]
credit.test <- credit.card[-train_ind, ]
nrow(credit.train)
nrow(credit.test)
set.seed(777)
train_ind <- sample(seq_len(nrow(credit.card)), size = floor(nrow(credit.card)*0.8), replace = FALSE)
credit.train <- credit.card[train_ind, ]
credit.test <- credit.card[-train_ind, ]
nrow(credit.train)
table(credit.train$Class)
nrow(credit.test)
table(credit.test$Class)
arbol = rpart(Class ~ ., data = credit.train)
get_pred_qual <- function(prediccion){
pred_qual=rep("0",dim(prediccion)[1])
pred_qual[prediccion[,2]>=0.5]="1"
return(as.factor(pred_qual))
}
pred_qual = get_pred_qual(predict(arbol, newdata = yeast.test))
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
F_meas(pred_qual,credit.test$Class)
arbol = rpart(Class ~ V1, data = credit.train)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
F_meas(pred_qual,credit.test$Class)
arbol = rpart(Class ~ V1, data = credit.train)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
F_meas(pred_qual, credit.test$Class)
prova.train = rbind(credit.train$V1, credit.train$Class)
prova.train
prova.train = rbind(credit.train[,'V1'], credit.train[,'Class'])
prova.train
prova.train = rbind(credit.train['V1'], credit.train['Class'])
prova.train
prova.train = rbind(credit.train['V1'], credit.train['Class'])
prova.train = credit.ttrain[c("V1","Class")]
prova.train
prova.train = credit.train[c("V1","Class")]
prova.train
prova.train = credit.train[c("V1","Class")]
prova.test = credit.test[c("V1","Class")]
arbol = rpart(Class ~ V1, data = prova.train)
pred_qual = get_pred_qual(predict(arbol, newdata = prova.test))
F_meas(pred_qual, prova.test$Class)
prova.train = credit.train[c("Time","Class")]
prova.test = credit.test[c("Time","Class")]
arbol = rpart(Class ~ V1, data = prova.train)
prova.train = credit.train[c("Time","Class")]
prova.test = credit.test[c("Time","Class")]
arbol = rpart(Class ~ Time, data = prova.train)
pred_qual = get_pred_qual(predict(arbol, newdata = prova.test))
F_meas(pred_qual, prova.test$Class)
pred_qual
prova.test$Class
pred_qual
prova.test$Class
prova.test$Class
pred_qu
pred_qual
F_meas(pred_qual, prova.test$Class)
F_meas(pred_qual, prova.test$Class)
precision(pred_qual, prova.test$Class)
arbol = rpart(Class ~ Time + V1, data = credit.train)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
prova.test$Class
pred_qual
F_meas(pred_qual, prova.test$Class)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
F_meas(pred_qual, prova.test$Class)
arbol = rpart(Class ~ V1 + V2, data = credit.train)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
F_meas(pred_qual, prova.test$Class)
arbol = rpart(Class ~ V3 + V2, data = credit.train)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
F_meas(pred_qual, prova.test$Class)
lift(pred_qual, prova.test$Class)
createConfusionMatrix(prova.test$Class, pred_qual)
confusionMatrix(data = pred_qual, prova.test$Class)
specificity(pred_qual, prova.test$Class)
sensitivity(pred_qual, prova.test$Class)
specificity(pred_qual, prova.test$Class)
confusionMatrix(data = pred_qual, prova.test$Class)
arbol = rpart(Class ~ V3 + V2, data = credit.train)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
sensitivity(pred_qual, prova.test$Class)
specificity(pred_qual, prova.test$Class)
confusionMatrix(data = pred_qual, prova.test$Class)
arbol = rpart(Class ~ ., data = credit.train)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
sensitivity(pred_qual, prova.test$Class)
specificity(pred_qual, prova.test$Class)
confusionMatrix(data = pred_qual, prova.test$Class)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
F_meas(pred_qual, prova.test$Class)
sensitivity(pred_qual, prova.test$Class)
specificity(pred_qual, prova.test$Class)
confusionMatrix(data = pred_qual, prova.test$Class)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
sensit = sensitivity(pred_qual, prova.test$Class)
specif = specificity(pred_qual, prova.test$Class)
balanced_acc = (sensit + specif) / 2
print("F1-measure:", paste(F_meas(pred_qual, prova.test$Class)))
print("Balanced Accuracy:", paste(balanced_acc))
print("Sensitivity:", paste(sensit))
print("Specificity:", paste(specif))
confusionMatrix(data = pred_qual, prova.test$Class)
pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
sensit = sensitivity(pred_qual, prova.test$Class)
specif = specificity(pred_qual, prova.test$Class)
balanced_acc = (sensit + specif) / 2
print(paste("F1-measure:", F_meas(pred_qual, prova.test$Class)))
print(paste("Balanced Accuracy:", balanced_acc))
print(paste("Sensitivity:", sensit))
print(paste("Specificity:", specif))
confusionMatrix(data = pred_qual, prova.test$Class)
get_pred_qual <- function(prediccion){
pred_qual=rep("0",dim(prediccion)[1])
pred_qual[prediccion[,2]>=0.5]="1"
return(as.factor(pred_qual))
}
print_metrics <- function(prediccion, gt, cf=FALSE){
pred_qual = get_pred_qual(prediccion)
sensit = sensitivity(pred_qual, gt)
specif = specificity(pred_qual, gt)
balanced_acc = (sensit + specif) / 2
print(paste("F1-measure:", F_meas(pred_qual, gt)))
print(paste("Balanced Accuracy:", balanced_acc))
print(paste("Sensitivity:", sensit))
print(paste("Specificity:", specif))
if(cf)
print(confusionMatrix(data = pred_qual, gt))
}
print_metrics(predict(arbol, newdata = credit.test))
print_metrics(predict(arbol, prova.test$Class, newdata = credit.test))
get_pred_qual <- function(prediccion){
pred_qual=rep("0",dim(prediccion)[1])
pred_qual[prediccion[,2]>=0.5]="1"
return(as.factor(pred_qual))
}
print_metrics <- function(prediccion, gt, cm=FALSE){
pred_qual = get_pred_qual(prediccion)
sensit = sensitivity(pred_qual, gt)
specif = specificity(pred_qual, gt)
balanced_acc = (sensit + specif) / 2
print(paste("F1-measure:", F_meas(pred_qual, gt)))
print(paste("Balanced Accuracy:", balanced_acc))
print(paste("Sensitivity:", sensit))
print(paste("Specificity:", specif))
if(cm)
print(confusionMatrix(data = pred_qual, gt))
}
print_metrics(predict(arbol, newdata = credit.test), prova.test$Class, cm=TRUE)
# pred_qual = get_pred_qual(predict(arbol, newdata = credit.test))
# sensit = sensitivity(pred_qual, prova.test$Class)
# specif = specificity(pred_qual, prova.test$Class)
# balanced_acc = (sensit + specif) / 2
# print(paste("F1-measure:", F_meas(pred_qual, prova.test$Class)))
# print(paste("Balanced Accuracy:", balanced_acc))
# print(paste("Sensitivity:", sensit))
# print(paste("Specificity:", specif))
# confusionMatrix(data = pred_qual, prova.test$Class)
get_pred_qual <- function(prediccion){
pred_qual=rep("0",dim(prediccion)[1])
pred_qual[prediccion[,2]>=0.5]="1"
return(as.factor(pred_qual))
}
print_metrics <- function(prediccion, gt, cm=FALSE){
if(cm)
print(confusionMatrix(data = pred_qual, gt))
else{
pred_qual = get_pred_qual(prediccion)
sensit = sensitivity(pred_qual, gt)
specif = specificity(pred_qual, gt)
balanced_acc = (sensit + specif) / 2
print(paste("F1-measure:", F_meas(pred_qual, gt)))
print(paste("Balanced Accuracy:", balanced_acc))
print(paste("Sensitivity:", sensit))
print(paste("Specificity:", specif))
}
}
print_metrics(predict(arbol, newdata = credit.test), prova.test$Class, cm=TRUE)
rbind(cnn$X, cnn$Y)
cnn = ubCNN(X=credit.train[, -ncol(credit.train)], Y=credit.train$Class, k=1)
rbind(cnn$X, cnn$Y)
to_dataframe <- function(results) {
new_df = res_ubsmote$X
new_df$Class = res_ubsmote$Y
}
table(cnn$Y)
arbol = rpart( Class ~ ., data = to_dataframe(cnn))
to_dataframe <- function(results) {
new_df = results$X
new_df$Class = results$Y
}
cnn = ubCNN(X=credit.train[, -ncol(credit.train)], Y=credit.train$Class, k=1)
table(cnn$Y)
arbol = rpart( Class ~ ., data = to_dataframe(cnn))
to_dataframe(cnn)
to_dataframe(cnn)
to_dataframe <- function(results) {
new_df = results$X
new_df$Class = results$Y
return(new_df)
}
to_dataframe(cnn)
table(cnn$Y)
arbol = rpart( Class ~ ., data = to_dataframe(cnn))
arbol = rpart( Class ~ ., data = to_dataframe(cnn))
